/* MyParser.jj */
options {
  // 是否是静态,这里要设置为false
  STATIC = false;
  // 开启调试解析打印,默认是false
  DEBUG_PARSER = false;
  // 生产java时使用jdk版本,默认1.5
  JDK_VERSION = "1.8";
}

PARSER_BEGIN(ActionParser)
import com.zhaoyunfei.javacc.module.dto.ARCActionDto;
import com.zhaoyunfei.javacc.module.dto.CircleActionDto;
import com.zhaoyunfei.javacc.module.dto.LineActionDto;
import com.zhaoyunfei.javacc.module.dto.PTPActionDto;
import com.zhaoyunfei.javacc.module.service.IExecuteService;
import lombok.extern.slf4j.Slf4j;

import java.util.HashMap;
import java.util.Map;



import java.util.HashMap;
import java.util.Map;

@Slf4j
public class ActionParser {
	// 业务接口
    private IExecuteService iExecuteService;
	
	// 存储变量的 Map
	private Map<String, Float> variables = new HashMap<String, Float>(); 
	
    private boolean executePTPAction(String parameters) {
        log.debug("Executing PTP action with parameters: " + parameters);
		// 分割参数
        String[] split = parameters.split(",");
		
        String param1 =split.length>0? split[0]:"";
		
        float param2 =split.length>1? Float.parseFloat(split[1]):0;
		
        float param3 =split.length>2? Float.parseFloat(split[2]):0;
		
        int param4 =split.length>3? Integer.parseInt(split[3]):0;

        float param5 =split.length>4? Float.parseFloat(split[4]):0;
		
        float param6 =split.length>5? Float.parseFloat(split[5]):0;
		
        float param7 =split.length>6? Float.parseFloat(split[6]):0;
		
        float param8 =split.length>7? Float.parseFloat(split[7]):0;
		
        float param9 =split.length>8? Float.parseFloat(split[8]):0;
		
        float param10 =split.length>9? Float.parseFloat(split[9]):0;

        PTPActionDto dto = new PTPActionDto(param1, param2, param3, param4, param5, param6, param7, param8, param9, param10);
        // 执行 PTP 动作
        return this.iExecuteService.executePtpAction(dto);
    }

    private boolean executeLINAction(String parameters) {
        log.debug("Executing LIN action with parameters: " + parameters);
		// 分割参数
        String[] split = parameters.split(",");
        
        String param1 =split.length>0? split[0]:"";
        
        float param2 =split.length>1? Float.parseFloat(split[1]):0;
        
        float param3 =split.length>2? Float.parseFloat(split[2]):0;
       
        int param4 =split.length>3? Integer.parseInt(split[3]):0;
        
        int param5 =split.length>4? Integer.parseInt(split[4]):0;

        float param6 =split.length>5? Float.parseFloat(split[5]):0;
		
        float param7 =split.length>6? Float.parseFloat(split[6]):0;
		
        float param8 =split.length>7? Float.parseFloat(split[7]):0;
		
        float param9 =split.length>8? Float.parseFloat(split[8]):0;
		
        float param10 =split.length>9? Float.parseFloat(split[9]):0;
		
        float param11 =split.length>10? Float.parseFloat(split[10]):0;

        LineActionDto dto = new LineActionDto(param1, param2, param3, param4, param5, param6, param7, param8, param9, param10, param11);
        // 执行 LIN动作
        return this.iExecuteService.executeLinAction(dto);
    }

    private boolean executeARCAction(String parameters) {
        log.debug("Executing ARC action with parameters: " + parameters);
		// 分割参数
        String[] split = parameters.split(",");
       
        String param1 =split.length>0? split[0]:""; 
       
        String param2 =split.length>1? split[1]:"";
		
        int param3 =split.length>2? Integer.parseInt(split[2]):0;
   
        float param4 =split.length>3? Float.parseFloat(split[3]):0;

		ARCActionDto dto=new ARCActionDto(param1,param2,param3,param4);
        // 执行 ARC 动作
        return this.iExecuteService.executeArcAction(dto);
    }

    private boolean executeCIRCLEAction(String parameters) {
        log.debug("Executing CIRCLE action with parameters: " + parameters);
		// 根据规则分割参数
        String[] split = parameters.split(",");
        
        String param1 =split.length>0? split[0]:"";
		
        String param2 =split.length>1? split[1]:"";

        int param3 =split.length>2? Integer.parseInt(split[2]):0;
        
        int param4 =split.length>3? Integer.parseInt(split[3]):0;

        float param5 =split.length>4? Float.parseFloat(split[4]):0;
		
        float param6 =split.length>5? Float.parseFloat(split[5]):0;
		
        float param7 =split.length>6? Float.parseFloat(split[6]):0;
		
        float param8 =split.length>7? Float.parseFloat(split[7]):0;
		
        float param9 =split.length>8? Float.parseFloat(split[8]):0;
		
        float param10 =split.length>9? Float.parseFloat(split[9]):0;

        CircleActionDto dto = new CircleActionDto(param1, param2, param3, param4, param5, param6, param7, param8, param9, param10);
        // 执行 CIRCLE动作
        return this.iExecuteService.executeCircleAction(dto);
    }

}
PARSER_END(ActionParser)

SKIP : {
  " " | "\t" | "\n" | "\r"
}

TOKEN : {
  <NUMBER: ("-")? (["0"-"9"])+ | ("-")? (["0"-"9"])+ "." (["0"-"9"])+ >
| <LPAREN: "(" >
| <RPAREN: ")" >
| <COMMA: "," > 
| <IF: "if" >
| <FOR: "for" >
| <DO: "do" >
| <END: "end" >
| <THEN: "then" >
| <PTP: "PTP">
| <LIN: "Lin">
| <ARC: "ARC">
| <CIRCLE: "Circle">
| <LESSTHAN: "<">
| <LESSTHANOREQUAL: "\u2264">
| <GREATERTHAN: ">" >
| <GREATERTHANOREQUAL: "\u2265" >
| <EQUALTO: "=" >
| <EQUAL: "==" >
| <NOTEQUAL: "\u2260" >
| <TRUE: "true" >
| <FALSE: "false" >
| <IDENTIFIER: (["a"-"z", "A"-"Z", "0"-"9", "\u4E00"-"\u9FA5"])+>
}

void Start() :
{} 
{
   Statement() ( Statement())*
}

// 根据需求将执行拆分为动作与条件
void Statement() :
{}
{
  (ActionStatement() | ConditionalStatement())+
}

// 为了解析不执行动作,但是文本还继续往后解析情况
void NoStatement() :
{}
{
  (NoActionStatement() | NoConditionalStatement())+
}

// 条件中: if,for循环,变量声明
void ConditionalStatement() :
{}
{
  IfStatement() | ForStatement()| Declaration()
}

void NoConditionalStatement() :
{}
{
  NoIfStatement() | NoForStatement()| NoDeclaration()
}

// 变量声明:这里主要是将变量存储在内存中,在需要使用时可以直接获取,实际调度解析比较的是值
void Declaration() :
{
  Token varName, value;
}
{
  varName = <IDENTIFIER> 
  value = <EQUALTO> 
  value = <NUMBER> 
  {
	// 获取变量名和值
	String name = varName.image;
	float val = Float.parseFloat(value.image);
	// 将变量名和值存储到 Map 中
	variables.put(name, val);
  }
}

void NoDeclaration() :
{}
{
   <IDENTIFIER><EQUALTO><NUMBER> 
}

// if条件解析并执行
void IfStatement() :
{
  boolean conditionResult;
}
{
  <IF> 
  conditionResult = Condition()
  <THEN> 
    {
      if (conditionResult) {
       Statement();
      }else{
		NoStatement(); 
	  }
    }
  <END> 
  
}

void NoIfStatement() :
{}
{
  <IF> NoCondition()<THEN>NoStatement()<END>
}

// for循环:解析的文本为 for i=0,2,1 do ...end
void ForStatement() :
{
  int start = 0;
  int end = 0;
  int increment = 1;
  // 用于保存当前 token 流的数组
  Token[] savedTokens = new Token[1];
}
{
  <FOR> <IDENTIFIER> <EQUALTO> <NUMBER> { start = Integer.parseInt(token.image); }
  <COMMA> <NUMBER> { end = Integer.parseInt(token.image); }
  <COMMA> <NUMBER> { increment = Integer.parseInt(token.image); }
  <DO>
  { savedTokens[0] = token; }
  // 循环体开始
  {
    // 检查循环终止条件
    while (start < end) {
      // 还原 token 流到上一个循环迭代之前的状态
      { token = savedTokens[0]; }
      // 执行循环体
      Statement();
       // 更新循环变量
      start += increment;
	  // 这里需要将下一个token置为空,这样会从token中重新获取,达到循环效果
	  jj_ntk=-1;
    }
  }
  <END>
}


void NoForStatement() :
{}
{
  <FOR> <IDENTIFIER> <EQUALTO> <NUMBER> <COMMA> <NUMBER> <COMMA> <NUMBER><DO>
  NoStatement()
  <END>
}

// 执行的动作:动作为同步执行,需要一步一步执行,可以根据具体情况修改
void ActionStatement() :
{boolean success=true;}
{
  success= Action()
  (
	{
		if(!success){
			break;
		}
	}
	success= Action()
  )*
}

void NoActionStatement() :
{}
{
   NoAction()(NoAction())*
}

// 定义了具体的执行动作,并将结果返回
boolean Action() :
{ boolean success = true; }
{
  (success=  PTPAction() | success=LINAction() |success= ARCAction() | success=CIRCLEAction() )
  { return success;}
}

void NoAction() :
{}
{
  NoPTPAction() | NoLINAction() | NoARCAction() | NoCIRCLEAction()
}

// ptp动作解析并执行(调度系统内接口)
boolean PTPAction() :
{}
{
  <PTP> { return executePTPAction(Parameters()); }
}

void NoPTPAction() :
{}
{
  <PTP> Parameters()
}

boolean LINAction() :
{}
{
  <LIN> {return executeLINAction(Parameters()); }
}

void NoLINAction() :
{}
{
  <LIN> Parameters()
}

boolean ARCAction() :
{}
{
  <ARC> { return executeARCAction(Parameters()); }
}

void NoARCAction() :
{}
{
  <ARC> Parameters()
}

boolean CIRCLEAction() :
{}
{
  <CIRCLE> {return executeCIRCLEAction(Parameters()); }
}

void NoCIRCLEAction() :
{}
{
  <CIRCLE> Parameters()
}

String Parameters() :
{
  StringBuilder params = new StringBuilder();
  String parameter;
   // 用于标记是否是第一个参数
  boolean isFirstParameter = true;
}
{
  <LPAREN>
  (
    parameter = Parameter()
    {
      // 如果不是第一个参数，则在参数前添加逗号
      if (!isFirstParameter) {
        params.append(",");
      }
      params.append(parameter);
	  // 将标记设为false，表示已经添加过第一个参数
      isFirstParameter = false;
    }
	// 解析剩余的参数
    (<COMMA> parameter = Parameter() { params.append(",").append(parameter); })*
  )?
  <RPAREN>
  { return params.toString(); }
}


String Parameter() :
{
  Token t;
}
{
  (
      t = <NUMBER> { return t.image; }
      | t = <IDENTIFIER> { return t.image; }
    )
}


boolean Condition() :
{
  boolean result = false;
  Token t1, t2;
  Token op;
}
{
  (
    (
      (
        t1 = <IDENTIFIER> 
        {
          String name1 = t1.image;
		  // 从存储的map中获取值
          float value1 = variables.getOrDefault(name1, 0f);
		  // 将 t1.image 设置为数字的字符串形式
          t1.image = Float.toString(value1); 
        }
      ) 
      | 
      (t1 = <NUMBER>) 
    )
    (op = <LESSTHAN> | op = <LESSTHANOREQUAL> | op = <GREATERTHAN> | op = <GREATERTHANOREQUAL> | op = <EQUAL> | op = <NOTEQUAL>)
    (
      (
        t2 = <IDENTIFIER> 
        {
          String name2 = t2.image;
		  // 从存储的map中获取值
          float value2 = variables.getOrDefault(name2, 0f);
		  // 将 t2.image 设置为数字的字符串形式
          t2.image = Float.toString(value2); 
        }
      ) 
      | 
      (t2 = <NUMBER>) 
    )
  ) 
  {
    // Evaluate the condition
    float value1 = Float.parseFloat(t1.image);
    float value2 = Float.parseFloat(t2.image);
    
    if (op.kind == LESSTHAN) {
      result = value1 < value2;
    } else if (op.kind == LESSTHANOREQUAL) {
      result = value1 <= value2;
    } else if (op.kind == GREATERTHAN) {
      result = value1 > value2;
    } else if (op.kind == GREATERTHANOREQUAL) {
      result = value1 >= value2;
    } else if (op.kind == EQUAL) {
      result = value1 == value2;
    } else if (op.kind == NOTEQUAL) {
      result = value1 != value2;
    }
  }
  {
    return result;
  }
}


void NoCondition() :
{}
{
  (<IDENTIFIER> | <NUMBER>) (<LESSTHAN> | <GREATERTHAN> | <EQUAL> | <NOTEQUAL>) (<IDENTIFIER> | <NUMBER>)
}
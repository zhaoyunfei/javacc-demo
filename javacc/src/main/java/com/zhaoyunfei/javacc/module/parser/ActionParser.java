package com.zhaoyunfei.javacc.module.parser;/* Generated By:JavaCC: Do not edit this line. ActionParser.java */

import com.zhaoyunfei.javacc.exceptions.CustomException;
import com.zhaoyunfei.javacc.module.dto.ARCActionDto;
import com.zhaoyunfei.javacc.module.dto.CircleActionDto;
import com.zhaoyunfei.javacc.module.dto.LineActionDto;
import com.zhaoyunfei.javacc.module.dto.PTPActionDto;
import com.zhaoyunfei.javacc.module.listener.ParsingListener;
import com.zhaoyunfei.javacc.module.service.IExecuteService;
import lombok.extern.slf4j.Slf4j;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.atomic.AtomicBoolean;

@Slf4j
public class ActionParser implements ActionParserConstants {

    private int currentLine = 0;
    // 业务接口
    private IExecuteService iExecuteService;

    private boolean breakLoop = false;

    private boolean continueLoop = false;

    private ParsingListener parsingListener;

    private final AtomicBoolean paused = new AtomicBoolean(false);

    private final AtomicBoolean stopped = new AtomicBoolean(false);

    // 存储变量�?? Map
    private final Map<String, Float> variables = new HashMap<String, Float>();

    // 当前行数状�??:0-执行�?,1-执行成功,2-执行失败
    private int status = 0;

    private boolean executePtpAction(String parameters) {
        log.debug("Executing PTP action with parameters: " + parameters);
        // 分割参数
        String[] split = parameters.split(",");

        String param1 = split.length > 0 ? split[0] : "";

        float param2 = split.length > 1 ? Float.parseFloat(split[1]) : 0;

        float param3 = split.length > 2 ? Float.parseFloat(split[2]) : 0;

        int param4 = split.length > 3 ? Integer.parseInt(split[3]) : 0;

        float param5 = split.length > 4 ? Float.parseFloat(split[4]) : 0;

        float param6 = split.length > 5 ? Float.parseFloat(split[5]) : 0;

        float param7 = split.length > 6 ? Float.parseFloat(split[6]) : 0;

        float param8 = split.length > 7 ? Float.parseFloat(split[7]) : 0;

        float param9 = split.length > 8 ? Float.parseFloat(split[8]) : 0;

        float param10 = split.length > 9 ? Float.parseFloat(split[9]) : 0;

        PTPActionDto dto = new PTPActionDto(param1, param2, param3, param4, param5, param6, param7, param8, param9, param10);
        // 执行 PTP 动作
        try {
            boolean b = this.iExecuteService.executePtpAction(dto);
            parsingListener.onParsingRead(currentLine, 1);
            return b;
        } catch (Exception e) {
            parsingListener.onParsingRead(currentLine, 2);
            throw new CustomException("\u93b5\u0446\ue511\u9366\u55d7\u59ec\u6769\u612c\u59e9\u6fb6\u8fab\u89e6,\u6fb6\u8fab\u89e6\u9358\u71b7\u6d1c:" + e.getMessage());
        }
    }

    private boolean executeLinAction(String parameters) {
        log.debug("Executing LIN action with parameters: " + parameters);
        // 分割参数
        String[] split = parameters.split(",");

        String param1 = split.length > 0 ? split[0] : "";

        float param2 = split.length > 1 ? Float.parseFloat(split[1]) : 0;

        float param3 = split.length > 2 ? Float.parseFloat(split[2]) : 0;

        int param4 = split.length > 3 ? Integer.parseInt(split[3]) : 0;

        int param5 = split.length > 4 ? Integer.parseInt(split[4]) : 0;

        float param6 = split.length > 5 ? Float.parseFloat(split[5]) : 0;

        float param7 = split.length > 6 ? Float.parseFloat(split[6]) : 0;

        float param8 = split.length > 7 ? Float.parseFloat(split[7]) : 0;

        float param9 = split.length > 8 ? Float.parseFloat(split[8]) : 0;

        float param10 = split.length > 9 ? Float.parseFloat(split[9]) : 0;

        float param11 = split.length > 10 ? Float.parseFloat(split[10]) : 0;

        LineActionDto dto = new LineActionDto(param1, param2, param3, param4, param5, param6, param7, param8, param9, param10, param11);
        // 执行 LIN动作
        try {
            boolean b = this.iExecuteService.executeLinAction(dto);
            parsingListener.onParsingRead(currentLine, 1);
            return b;
        } catch (Exception e) {
            parsingListener.onParsingRead(currentLine, 2);
            throw new CustomException("\u93b5\u0446\ue511\u9366\u55d7\u59ec\u6769\u612c\u59e9\u6fb6\u8fab\u89e6,\u6fb6\u8fab\u89e6\u9358\u71b7\u6d1c:" + e.getMessage());
        }
    }

    private boolean executeArcAction(String parameters) {
        log.debug("Executing ARC action with parameters: " + parameters);
        // 分割参数
        String[] split = parameters.split(",");

        String param1 = split.length > 0 ? split[0] : "";

        String param2 = split.length > 1 ? split[1] : "";

        int param3 = split.length > 2 ? Integer.parseInt(split[2]) : 0;

        float param4 = split.length > 3 ? Float.parseFloat(split[3]) : 0;

        ARCActionDto dto = new ARCActionDto(param1, param2, param3, param4);
        // 执行 ARC 动作
        try {
            boolean b = this.iExecuteService.executeArcAction(dto);
            parsingListener.onParsingRead(currentLine, 1);
            return b;
        } catch (Exception e) {
            parsingListener.onParsingRead(currentLine, 2);
            throw new CustomException("\u93b5\u0446\ue511\u9366\u55d7\u59ec\u6769\u612c\u59e9\u6fb6\u8fab\u89e6,\u6fb6\u8fab\u89e6\u9358\u71b7\u6d1c:" + e.getMessage());
        }
    }

    private boolean executeCircleAction(String parameters) {
        log.debug("Executing CIRCLE action with parameters: " + parameters);
        // 根据规则分割参数
        String[] split = parameters.split(",");

        String param1 = split.length > 0 ? split[0] : "";

        String param2 = split.length > 1 ? split[1] : "";

        int param3 = split.length > 2 ? Integer.parseInt(split[2]) : 0;

        int param4 = split.length > 3 ? Integer.parseInt(split[3]) : 0;

        float param5 = split.length > 4 ? Float.parseFloat(split[4]) : 0;

        float param6 = split.length > 5 ? Float.parseFloat(split[5]) : 0;

        float param7 = split.length > 6 ? Float.parseFloat(split[6]) : 0;

        float param8 = split.length > 7 ? Float.parseFloat(split[7]) : 0;

        float param9 = split.length > 8 ? Float.parseFloat(split[8]) : 0;

        float param10 = split.length > 9 ? Float.parseFloat(split[9]) : 0;

        CircleActionDto dto = new CircleActionDto(param1, param2, param3, param4, param5, param6, param7, param8, param9, param10);
        // 执行 CIRCLE动作
        try {
            boolean b = this.iExecuteService.executeCircleAction(dto);
            parsingListener.onParsingRead(currentLine, 1);
            return b;
        } catch (Exception e) {
            parsingListener.onParsingRead(currentLine, 2);
            throw new CustomException("\u93b5\u0446\ue511\u9366\u55d7\u59ec\u6769\u612c\u59e9\u6fb6\u8fab\u89e6,\u6fb6\u8fab\u89e6\u9358\u71b7\u6d1c:" + e.getMessage());
        }
    }

    public void pause() {
        paused.set(true);
    }

    public void resume() {
        paused.set(false);
        synchronized (paused) {
            paused.notifyAll();
        }
    }

    public void stop() {
        stopped.set(true);
    }

    final public void start() throws ParseException {
        statement();
        label_1:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case IF:
                case FOR:
                case WHILE:
                case CONTINUE_END:
                case PTP:
                case LIN:
                case ARC:
                case CIRCLE:
                case IDENTIFIER:
                    ;
                    break;
                default:
                    jj_la1[0] = jj_gen;
                    break label_1;
            }
            statement();
        }
    }

    // 根据�?求将执行拆分为动作与条件
    final public void statement() throws ParseException {
        label_2:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case PTP:
                case LIN:
                case ARC:
                case CIRCLE:
                    actionStatement();
                    break;
                case IF:
                case FOR:
                case WHILE:
                case CONTINUE_END:
                case IDENTIFIER:
                    conditionalStatement();
                    break;
                default:
                    jj_la1[1] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case IF:
                case FOR:
                case WHILE:
                case CONTINUE_END:
                case PTP:
                case LIN:
                case ARC:
                case CIRCLE:
                case IDENTIFIER:
                    ;
                    break;
                default:
                    jj_la1[2] = jj_gen;
                    break label_2;
            }
        }
    }

    // 为了解析不执行动�?,但是文本还继续往后解析情�?
    final public void noExecStatement() throws ParseException {
        label_3:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case IF:
                case FOR:
                case WHILE:
                case BREAK:
                case CONTINUE:
                case CONTINUE_END:
                case PTP:
                case LIN:
                case ARC:
                case CIRCLE:
                case IDENTIFIER:
                    ;
                    break;
                default:
                    jj_la1[3] = jj_gen;
                    break label_3;
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case PTP:
                case LIN:
                case ARC:
                case CIRCLE:
                    noExecActionStatement();
                    break;
                case IF:
                case FOR:
                case WHILE:
                case CONTINUE_END:
                case IDENTIFIER:
                    noExecConditionalStatement();
                    break;
                case BREAK:
                    noExecBreakStatement();
                    break;
                case CONTINUE:
                    noExecContinueStatement();
                    break;
                default:
                    jj_la1[4] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        }
    }

    // 条件�?: if,for循环,变量声明
    final public void conditionalStatement() throws ParseException {
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case IF:
                if (stopped.get()) {
                    noExecStatement();
                    {
                        if (true) return;
                    }
                }

                if (paused.get()) {
                    try {
                        synchronized (paused) {
                            paused.wait();
                        }
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        {
                            if (true) throw new ParseException("Thread interrupted while paused" + token);
                        }
                    }
                }
                ifStatement();
                break;
            case FOR:
            case WHILE:
                loopStatement();
                break;
            case IDENTIFIER:
                declaration();
                break;
            case CONTINUE_END:
                continueEnd();
                break;
            default:
                jj_la1[5] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
    }

    final public void noExecConditionalStatement() throws ParseException {
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case IF:
                noExecIfStatement();
                break;
            case FOR:
            case WHILE:
                noExecLoopStatement();
                break;
            case IDENTIFIER:
                noExecDeclaration();
                break;
            case CONTINUE_END:
                continueEnd();
                break;
            default:
                jj_la1[6] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
    }

    // 变量声明:这里主要是将变量存储在内存中,在需要使用时可以直接获取,实际调度解析比较的是�?
    final public void declaration() throws ParseException {
        Token varName, symbol, value1, value2;
        currentLine = token.beginLine;
        parsingListener.onParsingRead(currentLine, 0);
        varName = jj_consume_token(IDENTIFIER);
        symbol = jj_consume_token(EQUALTO);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case NUMBER:
                value1 = jj_consume_token(NUMBER);
                String name = varName.image;
                float val1 = Float.parseFloat(value1.image);
                variables.put(name, val1);
                break;
            case IDENTIFIER:
                value1 = jj_consume_token(IDENTIFIER);
                symbol = jj_consume_token(ADD);
                value2 = jj_consume_token(NUMBER);
                String variableName = varName.image;
                // 获取增加的�??
                float val = Float.parseFloat(value2.image);
                // 从变量集合中获取旧�??
                float oldValue = variables.getOrDefault(variableName, 0f);
                // 计算
                float result = val + oldValue;
                // 更新变量�?
                variables.put(variableName, result);
                break;
            default:
                jj_la1[7] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        currentLine = token.endLine;
        parsingListener.onParsingRead(currentLine, 1);
    }

    final public void noExecDeclaration() throws ParseException {
        jj_consume_token(IDENTIFIER);
        jj_consume_token(EQUALTO);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case NUMBER:
                jj_consume_token(NUMBER);
                break;
            case IDENTIFIER:
                jj_consume_token(IDENTIFIER);
                jj_consume_token(ADD);
                jj_consume_token(NUMBER);
                break;
            default:
                jj_la1[8] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
    }

    // if条件解析并执�?
    final public void ifStatement() throws ParseException {
        boolean conditionResult;
        if (breakLoop | continueLoop) {
            noExecStatement();
            {
                if (true) return;
            }
        }
        currentLine = token.beginLine;
        parsingListener.onParsingRead(currentLine, 0);
        jj_consume_token(IF);
        conditionResult = condition();
        jj_consume_token(THEN);
        currentLine = token.endLine;
        parsingListener.onParsingRead(currentLine, 1);
        if (conditionResult) {
            ifConditionStatement();
            if (breakLoop) {
                noExecStatement();
                {
                    if (true) return;
                }
            }
            if (continueLoop) {
                noExecStatement();
                {
                    if (true) return;
                }
            }
        } else {
            noExecStatement();
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case END:
                jj_consume_token(END);
                currentLine = token.endLine;
                parsingListener.onParsingRead(currentLine, 1);
                break;
            default:
                jj_la1[9] = jj_gen;
                ;
        }
    }

    final public void ifConditionStatement() throws ParseException {
        label_4:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case IF:
                case FOR:
                case WHILE:
                case BREAK:
                case CONTINUE:
                case CONTINUE_END:
                case PTP:
                case LIN:
                case ARC:
                case CIRCLE:
                case IDENTIFIER:
                    ;
                    break;
                default:
                    jj_la1[10] = jj_gen;
                    break label_4;
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case IF:
                case FOR:
                case WHILE:
                case CONTINUE_END:
                case PTP:
                case LIN:
                case ARC:
                case CIRCLE:
                case IDENTIFIER:
                    statement();
                    break;
                case BREAK:
                    jj_consume_token(BREAK);
                    breakLoop = true;
                    currentLine = token.endLine;
                    parsingListener.onParsingRead(currentLine, 1);
                    break;
                case CONTINUE:
                    jj_consume_token(CONTINUE);
                    this.continueLoop = true;
                    currentLine = token.endLine;
                    parsingListener.onParsingRead(currentLine, 1);
                    break;
                default:
                    jj_la1[11] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        }
    }

    final public void noExecIfStatement() throws ParseException {
        jj_consume_token(IF);
        noExecCondition();
        jj_consume_token(THEN);
        noExecStatement();
        jj_consume_token(END);
    }

    // for循环:解析的文本为 for i=0,2,1 do ...end 以及 for count=1,10 do ...end 循环执行10�?
    final public void loopStatement() throws ParseException {
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case FOR:
                forStatement();
                break;
            case WHILE:
                whileStatement();
                break;
            default:
                jj_la1[12] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
    }

    final public void forStatement() throws ParseException {
        String identy = "";
        int start = 0;
        int end = 0;
        // 这里这个1不能�?,为了
        int increment = 1;
        // 用于保存当前 token 流的数组
        Token[] savedTokens = new Token[1];
        currentLine = token.beginLine;
        parsingListener.onParsingRead(currentLine, 0);
        jj_consume_token(FOR);
        jj_consume_token(IDENTIFIER);
        identy = token.image;
        jj_consume_token(EQUALTO);
        jj_consume_token(NUMBER);
        start = Integer.parseInt(token.image);
        variables.put(identy, (float) start);
        jj_consume_token(COMMA);
        jj_consume_token(NUMBER);
        end = Integer.parseInt(token.image);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case COMMA:
                jj_consume_token(COMMA);
                jj_consume_token(NUMBER);
                increment = Integer.parseInt(token.image);
                jj_consume_token(DO);
                currentLine = token.endLine;
                parsingListener.onParsingRead(currentLine, 1);
                savedTokens[0] = token;
                // �?查循环终止条�?
                while (start < end) {
                    if (stopped.get()) {
                        noExecStatement();
                        {
                            if (true) return;
                        }
                    }
                    // 还原 token 流到上一个循环迭代之前的状�??
                    token = savedTokens[0];
                    jj_ntk = -1;
                    // 执行循环�?
                    forConditionStatement();
                    // 更新循环变量
                    start += increment;
                    variables.put(identy, (float) start);
                    if (breakLoop) {
                        noExecStatement();
                        breakLoop = false;
                        break;
                    }
                    if (continueLoop) {
                        noExecStatement();
                        continueLoop = false;
                        continue;
                    }

                }
                break;
            case DO:
                jj_consume_token(DO);
                currentLine = token.endLine;
                parsingListener.onParsingRead(currentLine, 1);
                savedTokens[0] = token;
                // �?查循环终止条�?
                while (start <= end) {
                    if (stopped.get()) {
                        noExecStatement();
                        {
                            if (true) return;
                        }
                    }
                    // 还原 token 流到上一个循环迭代之前的状�??
                    token = savedTokens[0];
                    // 执行循环�?
                    jj_ntk = -1;
                    forConditionStatement();
                    // 更新循环变量
                    start += increment;
                    variables.put(identy, (float) start);
                    if (breakLoop) {
                        noExecStatement();
                        breakLoop = false;
                        break;
                    }
                    if (continueLoop) {
                        noExecStatement();
                        continueLoop = false;
                        continue;
                    }
                }
                break;
            default:
                jj_la1[13] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case END:
                jj_consume_token(END);
                currentLine = token.endLine;
                parsingListener.onParsingRead(currentLine, 1);
                break;
            default:
                jj_la1[14] = jj_gen;
                ;
        }
    }

    final public void whileStatement() throws ParseException {
        boolean conditionResult;
        Token[] savedTokens = new Token[1];
        currentLine = token.beginLine;
        parsingListener.onParsingRead(currentLine, 0);
        jj_consume_token(WHILE);
        jj_consume_token(LPAREN);
        savedTokens[0] = token;
        // 保存当前解析位置
        conditionResult = condition();
        jj_consume_token(RPAREN);
        jj_consume_token(DO);
        currentLine = token.endLine;
        parsingListener.onParsingRead(currentLine, 1);
        while (conditionResult) {
            if (stopped.get()) {
                noExecStatement();
                {
                    if (true) return;
                }
            }
            forConditionStatement();
            // 还原 token 流到上一个循环迭代之前的状�??
            token = savedTokens[0];
            jj_ntk = -1;
            conditionResult = condition(); // 重新解析条件
            jj_consume_token(RPAREN);
            jj_consume_token(DO);

            if (breakLoop) {
                noExecStatement();
                breakLoop = false;
                break;
            }
            if (continueLoop) {
                noExecStatement();
                continueLoop = false;
                continue;
            }
        }
        if (!conditionResult) {
            noExecStatement();
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case END:
                jj_consume_token(END);
                currentLine = token.endLine;
                parsingListener.onParsingRead(currentLine, 1);
                break;
            default:
                jj_la1[15] = jj_gen;
                ;
        }
    }

    final public void forConditionStatement() throws ParseException {
        label_5:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case IF:
                case FOR:
                case WHILE:
                case BREAK:
                case CONTINUE:
                case CONTINUE_END:
                case PTP:
                case LIN:
                case ARC:
                case CIRCLE:
                case IDENTIFIER:
                    ;
                    break;
                default:
                    jj_la1[16] = jj_gen;
                    break label_5;
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case IF:
                case FOR:
                case WHILE:
                case CONTINUE_END:
                case PTP:
                case LIN:
                case ARC:
                case CIRCLE:
                case IDENTIFIER:
                    statement();
                    break;
                case BREAK:
                    jj_consume_token(BREAK);
                    this.breakLoop = true;
                    currentLine = token.endLine;
                    parsingListener.onParsingRead(currentLine, 1);
                    break;
                case CONTINUE:
                    jj_consume_token(CONTINUE);
                    this.continueLoop = true;
                    currentLine = token.endLine;
                    parsingListener.onParsingRead(currentLine, 1);
                    break;
                default:
                    jj_la1[17] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        }
    }

    final public void noExecBreakStatement() throws ParseException {
        jj_consume_token(BREAK);
    }

    final public void noExecContinueStatement() throws ParseException {
        jj_consume_token(CONTINUE);
    }

    final public void continueEnd() throws ParseException {
        jj_consume_token(CONTINUE_END);
        currentLine = token.endLine;
        parsingListener.onParsingRead(currentLine, 1);
    }

    final public void noExecLoopStatement() throws ParseException {
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case FOR:
                jj_consume_token(FOR);
                jj_consume_token(IDENTIFIER);
                jj_consume_token(EQUALTO);
                jj_consume_token(NUMBER);
                jj_consume_token(COMMA);
                jj_consume_token(NUMBER);
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case COMMA:
                        jj_consume_token(COMMA);
                        jj_consume_token(NUMBER);
                        break;
                    default:
                        jj_la1[18] = jj_gen;
                        ;
                }
                jj_consume_token(DO);
                noExecStatement();
                jj_consume_token(END);
                break;
            case WHILE:
                jj_consume_token(WHILE);
                jj_consume_token(LPAREN);
                noExecCondition();
                jj_consume_token(RPAREN);
                jj_consume_token(DO);
                noExecStatement();
                jj_consume_token(END);
                break;
            default:
                jj_la1[19] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
    }

    // 执行的动�?:动作为同步执�?,�?要一步一步执�?,可以根据具体情况修改
    final public void actionStatement() throws ParseException {
        boolean success = true;
        if (stopped.get()) {
            noExecStatement();
            {
                if (true) return;
            }
        }
        if (paused.get()) {
            try {
                synchronized (paused) {
                    paused.wait();
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                {
                    if (true) throw new ParseException("Thread interrupted while paused" + token);
                }
            }
        }
        if (breakLoop | continueLoop) {
            noExecStatement();
            {
                if (true) return;
            }
        }
        success = action();
        label_6:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case PTP:
                case LIN:
                case ARC:
                case CIRCLE:
                    ;
                    break;
                default:
                    jj_la1[20] = jj_gen;
                    break label_6;
            }
            if (!success) {
                break;
            }
            success = action();
        }
    }

    final public void noExecActionStatement() throws ParseException {
        noExecAction();
        label_7:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case PTP:
                case LIN:
                case ARC:
                case CIRCLE:
                    ;
                    break;
                default:
                    jj_la1[21] = jj_gen;
                    break label_7;
            }
            noExecAction();
        }
    }

    // 定义了具体的执行动作,并将结果返回
    final public boolean action() throws ParseException {
        boolean success = true;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case PTP:
                success = ptpAction();
                break;
            case LIN:
                success = linAction();
                break;
            case ARC:
                success = arcAction();
                break;
            case CIRCLE:
                success = circleAction();
                break;
            default:
                jj_la1[22] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {
            if (true) return success;
        }
        throw new Error("Missing return statement in function");
    }

    final public void noExecAction() throws ParseException {
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case PTP:
                noExecPtpAction();
                break;
            case LIN:
                noExecLinAction();
                break;
            case ARC:
                noExecArcAction();
                break;
            case CIRCLE:
                noExecCircleAction();
                break;
            default:
                jj_la1[23] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
    }

    // ptp动作解析并执�?(调度系统内接�?)
    final public boolean ptpAction() throws ParseException {
        jj_consume_token(PTP);
        currentLine = token.endLine;
        parsingListener.onParsingRead(currentLine, 0);
        {
            if (true) return executePtpAction(parameters());
        }
        throw new Error("Missing return statement in function");
    }

    final public void noExecPtpAction() throws ParseException {
        jj_consume_token(PTP);
        parameters();
    }

    final public boolean linAction() throws ParseException {
        jj_consume_token(LIN);
        currentLine = token.endLine;
        parsingListener.onParsingRead(currentLine, 0);
        {
            if (true) return executeLinAction(parameters());
        }
        throw new Error("Missing return statement in function");
    }

    final public void noExecLinAction() throws ParseException {
        jj_consume_token(LIN);
        parameters();
    }

    final public boolean arcAction() throws ParseException {
        jj_consume_token(ARC);
        currentLine = token.endLine;
        parsingListener.onParsingRead(currentLine, 0);
        {
            if (true) return executeArcAction(parameters());
        }
        throw new Error("Missing return statement in function");
    }

    final public void noExecArcAction() throws ParseException {
        jj_consume_token(ARC);
        parameters();
    }

    final public boolean circleAction() throws ParseException {
        jj_consume_token(CIRCLE);
        currentLine = token.endLine;
        parsingListener.onParsingRead(currentLine, 0);
        {
            if (true) return executeCircleAction(parameters());
        }
        throw new Error("Missing return statement in function");
    }

    final public void noExecCircleAction() throws ParseException {
        jj_consume_token(CIRCLE);
        parameters();
    }

    final public String parameters() throws ParseException {
        StringBuilder params = new StringBuilder();
        String parameter;
        // 用于标记是否是第�?个参�?
        boolean isFirstParameter = true;
        jj_consume_token(LPAREN);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case NUMBER:
            case IDENTIFIER:
                parameter = parameter();
                // 如果不是第一个参数，则在参数前添加�?�号
                if (!isFirstParameter) {
                    params.append(",");
                }
                params.append(parameter);
                // 将标记设为false，表示已经添加过第一个参�?
                isFirstParameter = false;
                label_8:
                while (true) {
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case COMMA:
                            ;
                            break;
                        default:
                            jj_la1[24] = jj_gen;
                            break label_8;
                    }
                    jj_consume_token(COMMA);
                    parameter = parameter();
                    params.append(",").append(parameter);
                }
                break;
            default:
                jj_la1[25] = jj_gen;
                ;
        }
        jj_consume_token(RPAREN);
        {
            if (true) return params.toString();
        }
        throw new Error("Missing return statement in function");
    }

    final public String parameter() throws ParseException {
        Token t;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case NUMBER:
                t = jj_consume_token(NUMBER);
            {
                if (true) return t.image;
            }
            break;
            case IDENTIFIER:
                t = jj_consume_token(IDENTIFIER);
            {
                if (true) return t.image;
            }
            break;
            default:
                jj_la1[26] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        throw new Error("Missing return statement in function");
    }

    final public boolean condition() throws ParseException {
        boolean result = false;
        Token t1, t2;
        Token op;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case IDENTIFIER:
                t1 = jj_consume_token(IDENTIFIER);
                break;
            case NUMBER:
                t1 = jj_consume_token(NUMBER);
                break;
            default:
                jj_la1[27] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case LESSTHAN:
                op = jj_consume_token(LESSTHAN);
                break;
            case LESSTHANOREQUAL:
                op = jj_consume_token(LESSTHANOREQUAL);
                break;
            case GREATERTHAN:
                op = jj_consume_token(GREATERTHAN);
                break;
            case GREATERTHANOREQUAL:
                op = jj_consume_token(GREATERTHANOREQUAL);
                break;
            case EQUAL:
                op = jj_consume_token(EQUAL);
                break;
            case NOTEQUAL:
                op = jj_consume_token(NOTEQUAL);
                break;
            default:
                jj_la1[28] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case IDENTIFIER:
                t2 = jj_consume_token(IDENTIFIER);
                break;
            case NUMBER:
                t2 = jj_consume_token(NUMBER);
                break;
            default:
                jj_la1[29] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        // 获取变量名和�?
        String name1 = t1.image;
        String name2 = t2.image;
        float value1 = 0f;
        float value2 = 0f;

        if (t1.kind == IDENTIFIER) {
            value1 = variables.getOrDefault(name1, 0f);
        } else {
            value1 = Float.parseFloat(name1);
        }

        if (t2.kind == IDENTIFIER) {
            value2 = variables.getOrDefault(name2, 0f);
        } else {
            value2 = Float.parseFloat(name2);
        }

        // 根据操作符计算条件结�?
        if (op.kind == LESSTHAN) {
            result = value1 < value2;
        } else if (op.kind == LESSTHANOREQUAL) {
            result = value1 <= value2;
        } else if (op.kind == GREATERTHAN) {
            result = value1 > value2;
        } else if (op.kind == GREATERTHANOREQUAL) {
            result = value1 >= value2;
        } else if (op.kind == EQUAL) {
            result = value1 == value2;
        } else if (op.kind == NOTEQUAL) {
            result = value1 != value2;
        }
        {
            if (true) return result;
        }
        throw new Error("Missing return statement in function");
    }

    final public void noExecCondition() throws ParseException {
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case IDENTIFIER:
                jj_consume_token(IDENTIFIER);
                break;
            case NUMBER:
                jj_consume_token(NUMBER);
                break;
            default:
                jj_la1[30] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case LESSTHAN:
                jj_consume_token(LESSTHAN);
                break;
            case GREATERTHAN:
                jj_consume_token(GREATERTHAN);
                break;
            case EQUAL:
                jj_consume_token(EQUAL);
                break;
            case NOTEQUAL:
                jj_consume_token(NOTEQUAL);
                break;
            default:
                jj_la1[31] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case IDENTIFIER:
                jj_consume_token(IDENTIFIER);
                break;
            case NUMBER:
                jj_consume_token(NUMBER);
                break;
            default:
                jj_la1[32] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
    }

    /**
     * Generated Token Manager.
     */
    public ActionParserTokenManager token_source;
    SimpleCharStream jj_input_stream;
    /**
     * Current token.
     */
    public Token token;
    /**
     * Next token.
     */
    public Token jj_nt;
    private int jj_ntk;
    private int jj_gen;
    final private int[] jj_la1 = new int[33];
    static private int[] jj_la1_0;
    static private int[] jj_la1_1;

    static {
        jj_la1_init_0();
        jj_la1_init_1();
    }

    private static void jj_la1_init_0() {
        jj_la1_0 = new int[]{0x3c4e00, 0x3c4e00, 0x3c4e00, 0x3c7e00, 0x3c7e00, 0x4e00, 0x4e00, 0x20, 0x20, 0x10000, 0x3c7e00, 0x3c7e00, 0xc00, 0x8100, 0x10000, 0x10000, 0x3c7e00, 0x3c7e00, 0x100, 0xc00, 0x3c0000, 0x3c0000, 0x3c0000, 0x3c0000, 0x100, 0x20, 0x20, 0x20, 0x2bc00000, 0x20, 0x20, 0x29400000, 0x20,};
    }

    private static void jj_la1_init_1() {
        jj_la1_1 = new int[]{0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x0, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x1, 0x0, 0x1, 0x1, 0x0, 0x1,};
    }

    /**
     * Constructor with InputStream.
     */
    public ActionParser(java.io.InputStream stream,IExecuteService iExecuteService,ParsingListener parsingListener) {
        this(stream, null,iExecuteService,parsingListener);
    }

    /**
     * Constructor with InputStream and supplied encoding
     */
    public ActionParser(java.io.InputStream stream, String encoding,IExecuteService iExecuteService,ParsingListener parsingListener) {
        try {
            jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1);
        } catch (java.io.UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
        token_source = new ActionParserTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 33; i++) jj_la1[i] = -1;
        this.iExecuteService=iExecuteService;
        this.parsingListener=parsingListener;
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.InputStream stream) {
        ReInit(stream, null);
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.InputStream stream, String encoding) {
        try {
            jj_input_stream.ReInit(stream, encoding, 1, 1);
        } catch (java.io.UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 33; i++) jj_la1[i] = -1;
    }

    /**
     * Constructor.
     */
    public ActionParser(java.io.Reader stream) {
        jj_input_stream = new SimpleCharStream(stream, 1, 1);
        token_source = new ActionParserTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 33; i++) jj_la1[i] = -1;
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.Reader stream) {
        jj_input_stream.ReInit(stream, 1, 1);
        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 33; i++) jj_la1[i] = -1;
    }

    /**
     * Constructor with generated Token Manager.
     */
    public ActionParser(ActionParserTokenManager tm) {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 33; i++) jj_la1[i] = -1;
    }

    /**
     * Reinitialise.
     */
    public void ReInit(ActionParserTokenManager tm) {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 33; i++) jj_la1[i] = -1;
    }

    private Token jj_consume_token(int kind) throws ParseException {
        Token oldToken;
        if ((oldToken = token).next != null) token = token.next;
        else token = token.next = token_source.getNextToken();
        jj_ntk = -1;
        if (token.kind == kind) {
            jj_gen++;
            return token;
        }
        token = oldToken;
        jj_kind = kind;
        throw generateParseException();
    }


    /**
     * Get the next Token.
     */
    final public Token getNextToken() {
        if (token.next != null) token = token.next;
        else token = token.next = token_source.getNextToken();
        jj_ntk = -1;
        jj_gen++;
        return token;
    }

    /**
     * Get the specific Token.
     */
    final public Token getToken(int index) {
        Token t = token;
        for (int i = 0; i < index; i++) {
            if (t.next != null) t = t.next;
            else t = t.next = token_source.getNextToken();
        }
        return t;
    }

    private int jj_ntk() {
        if ((jj_nt = token.next) == null)
            return (jj_ntk = (token.next = token_source.getNextToken()).kind);
        else
            return (jj_ntk = jj_nt.kind);
    }

    private java.util.List jj_expentries = new java.util.ArrayList();
    private int[] jj_expentry;
    private int jj_kind = -1;

    /**
     * Generate ParseException.
     */
    public ParseException generateParseException() {
        jj_expentries.clear();
        boolean[] la1tokens = new boolean[33];
        if (jj_kind >= 0) {
            la1tokens[jj_kind] = true;
            jj_kind = -1;
        }
        for (int i = 0; i < 33; i++) {
            if (jj_la1[i] == jj_gen) {
                for (int j = 0; j < 32; j++) {
                    if ((jj_la1_0[i] & (1 << j)) != 0) {
                        la1tokens[j] = true;
                    }
                    if ((jj_la1_1[i] & (1 << j)) != 0) {
                        la1tokens[32 + j] = true;
                    }
                }
            }
        }
        for (int i = 0; i < 33; i++) {
            if (la1tokens[i]) {
                jj_expentry = new int[1];
                jj_expentry[0] = i;
                jj_expentries.add(jj_expentry);
            }
        }
        int[][] exptokseq = new int[jj_expentries.size()][];
        for (int i = 0; i < jj_expentries.size(); i++) {
            exptokseq[i] = (int[]) jj_expentries.get(i);
        }
        return new ParseException(token, exptokseq, tokenImage);
    }

    /**
     * Enable tracing.
     */
    final public void enable_tracing() {
    }

    /**
     * Disable tracing.
     */
    final public void disable_tracing() {
    }

}
